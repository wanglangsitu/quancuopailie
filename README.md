# quancuopailie
全错排列的Python求解

假设项数为n，全错排列种数为An

首先算出总排列种数n！，而后依次减去存在正确摆放的情况

0个数摆放错误，共C（n，0）种选择，每种选择又存在项数为0的全错排列种数的情况A0，故总和为C（n，0）*A0；实际上是不存在项数为0的排列的，只是为了Python下标系统的统一以及循环语句的便捷性，令A0=1，对应全对排列1种

1个数摆放错误，共C（n，1）种选择，每种选择又存在项数为1的全错排列种数的情况A1，故总和为C（n，1）*A1；实际上项数为的排列是不存在排错这种说法的，故A1=0

2个数摆放错误，共C（n，2）种选择，每种选择又存在项数为2的全错排列种数的情况A2，故总和为C（n，2）*A2

3个数摆放错误，共C（n，3）种选择，每种选择又存在项数为3的全错排列种数的情况A3，故总和为C（n，3）*A3

……

k个数摆放错误，共C（n，k）种选择，每种选择又存在项数为k的全错排列种数的情况Ak，故总和为C（n，k）*Ak

……

n-2个数摆放错误，共C（n，n-2）种选择，每种选择又存在项数为n-2的全错排列种数的情况A(n-2)，故总和为C（n，n-2）*A(n-2)

n-1个数摆放错误，共C（n，n-1）种选择，每种选择又存在项数为n-1的全错排列种数的情况A(n-1)，故总和为C（n，n-1）*A(n-1)

从n！中将上述所有结果依次减去，得到的就是n项全部排列错误的情况，即An

可见，该思路下，需要将项数小于n的所有全错排序结果全部算出，而后进行反复迭代。对于人力计算而言，只能考虑项数较小的情况，但是这种限制在计算机算力面前显然是不值一提的。我们只需要建立一个list，list中的每一项都是项数为n时的全错排列种数（n=0开始）。通过for循环将n之前的全错排列种数依次算出，添加至list的末尾，在下一轮计算中进行调取即可。涉及双重for循环语句，思路不难，但是需要理清头绪。
